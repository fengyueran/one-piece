---
alwaysApply: true
---

# Compass UI - 开发规则

## 0. 包管理器规范

### 0.1 使用 pnpm

- **必须使用 pnpm 作为包管理器**
- 安装依赖：`pnpm install`
- 添加依赖：`pnpm add <package>`
- 添加开发依赖：`pnpm add -D <package>`
- 运行脚本：`pnpm run <script>` 或 `pnpm <script>`

## 1. 组件开发规范

### 1.1 组件结构

- 每个组件必须在 `src/` 目录下的独立目录中
- 文件夹名和文件名使用 kebab-case（例如：`button-base`, `input-field`）
- 目录结构：

  ```text
  component-name/
  ├── index.ts                  # 导出文件
  ├── component-name.tsx        # 主组件
  ├── component-name.test.tsx   # 单元测试
  ├── component-name.stories.tsx # Storybook 文档
  ├── types.ts                  # 类型定义
  └── styles.ts                 # 样式（使用 @emotion/styled）
  ```

### 1.2 组件命名

- 组件名（类名）使用 PascalCase（例如：`ButtonBase`, `InputField`）
- 文件夹名和文件名使用 kebab-case（例如：`button-base`, `input-field`）
- Props 接口命名为 `ComponentNameProps`
- 样式组件命名为 `StyledComponentName`

### 1.3 组件 Props 设计

- 必须定义 TypeScript 接口
- 所有 Props 必须有 JSDoc 注释说明用途
- 支持 `className` 和 `style` 属性以便自定义
- 使用 `React.forwardRef` 转发 ref
- 示例：

  ```typescript
  export interface ButtonProps {
    /** Button type */
    type?: 'primary' | 'secondary' | 'danger'
    /** Button size */
    size?: 'small' | 'medium' | 'large'
    /** Disabled state */
    disabled?: boolean
    /** Click handler */
    onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void
    /** Custom className */
    className?: string
    /** Custom style */
    style?: React.CSSProperties
    /** Button content */
    children?: React.ReactNode
  }
  ```

### 1.4 className 命名规范

- **组件根元素必须添加标准化的 className**
- className 格式：`compass-{component-name} compass-{component-name}--{variant} {customClassName}`
- 组件名使用 kebab-case
- variant 使用 kebab-case
- 示例：

  ```typescript
  // Button 组件
  className={`compass-button compass-button--${variant} ${className || ''}`}

  // Progress 组件
  className={`compass-progress compass-progress--${type} ${className || ''}`}

  // InputField 组件
  className={`compass-input-field compass-input-field--${size} ${className || ''}`}
  ```

- **规则说明：**
  - 基础类名：`compass-{component-name}` - 用于基础样式和组件识别
  - 变体类名：`compass-{component-name}--{variant}` - 用于不同变体的样式
  - 自定义类名：`${className || ''}` - 支持用户传入的自定义类名
  - 类名之间用空格分隔
  - 如果没有 variant，可以省略变体类名

### 1.5 导出规范

- 每个组件目录的 `index.ts` 导出组件和类型
- `src/index.ts` 统一导出所有公共 API

- 导出示例：

  ```typescript
  // button-base/index.ts
  export { Button } from './button'
  export type { ButtonProps } from './button'

  // src/index.ts
  export { Button } from './button-base'
  export type { ButtonProps } from './button-base'
  ```

## 2. TypeScript 规范

### 2.1 类型定义

- 优先使用 `interface` 定义对象类型
- 使用 `type` 定义联合类型和工具类型
- 避免使用 `any`，必要时使用 `unknown`
- 所有公共 API 必须有完整的类型定义

### 2.2 泛型使用

- 需要类型复用时使用泛型
- 泛型参数使用有意义的名称（不只是 `T`）
- 提供合理的默认类型参数

### 2.3 严格模式

- 启用 TypeScript 严格模式
- 不允许隐式 `any`
- 必须处理 `null` 和 `undefined`

## 3. 测试规范 ⚠️

### 3.1 测试覆盖率要求

- **所有组件必须有单元测试**
- 测试覆盖率目标：
  - 语句覆盖率 ≥ 80%
  - 分支覆盖率 ≥ 75%
  - 函数覆盖率 ≥ 80%
  - 行覆盖率 ≥ 80%

### 3.2 测试文件命名

- 测试文件命名：`component-name.test.tsx`（kebab-case）
- 与被测试文件放在同一目录

### 3.3 测试内容（必须包含）

- ✅ **渲染测试**：验证组件能正常渲染
- ✅ **Props 测试**：测试所有 props 的效果
- ✅ **交互测试**：测试用户交互（点击、输入等）
- ✅ **状态测试**：测试不同状态下的表现
- ✅ **可访问性测试**：验证 ARIA 属性和键盘导航
- ✅ **边界测试**：测试边界情况和错误处理

### 3.4 测试示例结构

```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import { Button } from './button'

describe('Button', () => {
  describe('Rendering', () => {
    it('should render with default props', () => {
      render(<Button>Click me</Button>)
      expect(screen.getByRole('button')).toBeInTheDocument()
    })
  })

  describe('Props', () => {
    it('should apply disabled state', () => {
      render(<Button disabled>Click me</Button>)
      expect(screen.getByRole('button')).toBeDisabled()
    })
  })

  describe('Interactions', () => {
    it('should call onClick handler', () => {
      const handleClick = jest.fn()
      render(<Button onClick={handleClick}>Click me</Button>)
      fireEvent.click(screen.getByRole('button'))
      expect(handleClick).toHaveBeenCalledTimes(1)
    })
  })

  describe('Accessibility', () => {
    it('should have correct ARIA attributes', () => {
      render(<Button aria-label="Submit form">Submit</Button>)
      expect(screen.getByLabelText('Submit form')).toBeInTheDocument()
    })
  })
})
```

### 3.5 测试工具

- 使用 Jest 作为测试框架
- 使用 @testing-library/react 进行组件测试
- 使用 @testing-library/user-event 模拟用户交互
- 避免使用快照测试（snapshot），优先使用行为测试

### 3.6 测试最佳实践

- 测试行为而非实现细节
- 使用语义化查询（role, label, text）而非 className 或 data-testid
- 每个测试应该独立且可重复
- 测试描述清晰明确，说明测试目的
- Mock 外部依赖和副作用

## 4. 样式规范

### 4.1 样式系统

- 使用 `@emotion/styled` 编写样式
- 使用 `@emotion/react` 的 css prop（必要时）
- 支持主题定制
- **组件必须提供默认样式**：确保在没有 `ThemeProvider` 的情况下，组件也能正常显示，所有依赖主题的样式都必须有备用值。

### 4.2 样式文件

- 样式定义在单独的 `styles.ts` 文件中
- 使用 styled components 创建样式组件
- 示例：

  ```typescript
  import styled from '@emotion/styled'

  export const StyledButton = styled.button<{ size?: 'small' | 'medium' | 'large' }>`
    padding: ${(props) => (props.size === 'small' ? '4px 8px' : '8px 16px')};
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;

    &:hover {
      opacity: 0.8;
    }

    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  `
  ```

### 4.3 响应式设计

- 使用媒体查询实现响应式
- 考虑移动端和桌面端体验

## 5. 文档规范

### 5.1 Storybook 文档

为了确保文档的可读性、完整性与自动化能力，**每个组件的 Story
文档必须遵循以下要求：**

-   **必须完整描述组件的所有 Props**（用途、类型、默认值）
-   **必须包含组件主题（Component
    Theme）的说明**：组件可配置的主题字段、支持的主题变量
-   **必须包含全局主题， 组件主题

### 5.2 代码注释

- 所有公共 API 使用 JSDoc/TSDoc
- 复杂逻辑添加行内注释说明
- 注释使用英文（除非特殊要求）

### 5.3 JSDoc 示例

````typescript
/**
 * A flexible button component with various styles and sizes.
 *
 * @example
 * ```tsx
 * <Button type="primary" size="large" onClick={handleClick}>
 *   Click me
 * </Button>
 * ```
 */
export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
  // implementation
})
````

## 6. 可访问性规范（A11y）

### 6.1 语义化 HTML

- 使用语义化 HTML 标签
- 正确使用 ARIA 属性
- 支持键盘导航

### 6.2 必须支持

- ✅ 键盘导航（Tab, Enter, Space, Arrow keys）
- ✅ Screen reader 支持
- ✅ 焦点管理
- ✅ 适当的 ARIA roles 和 attributes

### 6.3 测试要点

- 使用键盘测试所有交互
- 使用 screen reader 测试
- 检查 ARIA 属性是否正确

## 7. 性能规范

### 7.1 渲染优化

- 使用 `React.memo` 避免不必要的重渲染
- 合理使用 `useMemo` 和 `useCallback`
- 避免在渲染函数中创建新对象/函数

### 7.2 包体积

- 避免引入大型依赖
- 支持 tree-shaking
- 懒加载大型组件

## 8. 代码质量

### 8.1 Linting

- 运行 `pnpm lint` 检查代码
- 提交前必须通过 lint 检查
- 遵循 ESLint 规则

### 8.2 代码审查检查清单

- [ ] 类型定义完整
- [ ] 有单元测试且通过
- [ ] 有 Storybook 文档
- [ ] 通过 lint 检查
- [ ] 支持可访问性
- [ ] Props 有 JSDoc 注释
- [ ] 遵循 className 命名规范
- [ ] 性能考虑合理
- [ ] 错误处理完善

## 9. 发布规范

### 9.1 版本管理

- 遵循 Semantic Versioning (SemVer)
- MAJOR.MINOR.PATCH

### 9.2 变更日志

- 维护 CHANGELOG.md
- 记录每次发布的变更
